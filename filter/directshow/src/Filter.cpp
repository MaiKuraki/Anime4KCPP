#include <cstddef>
#include <memory>
#include <new>
#include <string>

#include <streams.h>
#include <dvdmedia.h>
#include <tchar.h>
#include <initguid.h>
#include <wrl/client.h>

#include "AC/Core.hpp"
#include "AC/Specs.hpp"

#include "Registry.hpp"
#include "SideData.hpp"

#include "resource.hpp" // Generated by CMake

#define A2T(s) (sizeof(TCHAR) == sizeof(char) ? (LPCTSTR)(s) : (util::asciiToString<TCHAR>(s).c_str()))
#define T2A(s) (sizeof(TCHAR) == sizeof(char) ? (LPCSTR)(s) : (util::asciiToString<char>(s).c_str()))

namespace util
{
    template<typename CharOut, typename CharIn>
    static inline std::basic_string<CharOut> asciiToString(const CharIn* const str)
    {
        std::basic_string<CharOut> buffer{};
        for (auto p = str; *p; p++) buffer.push_back(static_cast<CharOut>(*p));
        return buffer;
    }

    template<typename CharOut, typename CharIn, typename SizeType>
    static inline SizeType asciiToWindowsAscii(const CharIn* const str, CharOut* const buffer, const SizeType size)
    {
        SizeType count = 0;
        for (auto p = str; *p && (count < size - 1); p++)
        {
            CharOut ch = static_cast<CharOut>(*p);
            if (ch == static_cast<CharOut>('\n')) buffer[count++] = static_cast<CharOut>('\r');
            buffer[count++] = ch;
        }
        buffer[count] = static_cast<CharOut>('\0');
        return count;
    }
}

DEFINE_GUID(CLSID_AC_FILTER, 0x731ae2e9, 0xeeed, 0x4e29, 0xb8, 0x1b, 0x5d, 0xc8, 0xa0, 0xd6, 0xa3, 0x07);
class Filter : public CTransformFilter, public ISpecifyPropertyPages
{
public:
    static CUnknown* WINAPI CreateInstance(LPUNKNOWN punk, HRESULT* phr);

public:
    DECLARE_IUNKNOWN;

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void** ppv) override;
    CBasePin* GetPin(int n) override;

    HRESULT CheckInputType(const CMediaType* mtIn) override;
    HRESULT CheckTransform(const CMediaType* mtIn, const CMediaType* mtOut) override;
    HRESULT GetMediaType(int pos, CMediaType* mt) override;
    HRESULT DecideBufferSize(IMemAllocator* alloctor, ALLOCATOR_PROPERTIES* request) override;
    HRESULT Transform(IMediaSample* in, IMediaSample* out) override;

    STDMETHODIMP GetPages(CAUUID* pages) override;

private:
    Filter(TCHAR* name, LPUNKNOWN punk, HRESULT* phr) noexcept;

private:
    struct Size { int width, height; } limit{};

    struct
    {
        Size src, dst;
        int channels;
        int part;
    } luma{}, chroma{};

    int totalParts{};

    struct Format
    {
        ac::core::Image::ElementType type = 0;
        struct {
            int w = 0, h = 0;
        } subsampling{};
        bool packed{};

        operator bool() const noexcept
        {
            return type != 0 && subsampling.w != 0 && subsampling.h != 0;
        }
    } format{};

private:
    double factor{};
    std::shared_ptr<ac::core::Processor> processor{};
};
DEFINE_GUID(CLSID_AC_PROPERTY_PAGE, 0x2548fd44, 0x5370, 0x40f6, 0x99, 0x66, 0x48, 0x5d, 0x7b, 0xac, 0x71, 0x3c);
class PropertyPage : public CBasePropertyPage
{
public:
    static CUnknown* WINAPI CreateInstance(LPUNKNOWN punk, HRESULT* phr);

private:
    INT_PTR OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) override;
    HRESULT OnActivate() override;
    HRESULT OnDeactivate() override;
    HRESULT OnApplyChanges() override;

private:
    PropertyPage(TCHAR* name, LPUNKNOWN punk, HRESULT* phr) noexcept;

private:
    static constexpr int StringBufferSize = 512;

    bool isInitialized = false;
};

DEFINE_GUID(MEDIASUBTYPE_I420, 0x30323449, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_YV16, 0x36315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_YV24, 0x34325659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_P210, 0x30313250, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_P216, 0x36313250, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(MEDIASUBTYPE_NV24, 0x3432564e, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

const AMOVIESETUP_MEDIATYPE sudPinTypes[] =
{
    {
        &MEDIATYPE_Video,
        &MEDIASUBTYPE_I420
    },
    {
        &MEDIATYPE_Video,
        &MEDIASUBTYPE_IYUV
    },
    {
        &MEDIATYPE_Video,
        &MEDIASUBTYPE_YV12
    },
    {
        &MEDIATYPE_Video,
        &MEDIASUBTYPE_NV12
    },
    {
        &MEDIATYPE_Video,
        &MEDIASUBTYPE_P010
    },
    {
        &MEDIATYPE_Video,
        &MEDIASUBTYPE_P016
    },
    {
        &MEDIATYPE_Video,
        &MEDIASUBTYPE_YV16
    },
    {
        &MEDIATYPE_Video,
        &MEDIASUBTYPE_P210
    },
    {
        &MEDIATYPE_Video,
        &MEDIASUBTYPE_P216
    },
    {
        &MEDIATYPE_Video,
        &MEDIASUBTYPE_YV24
    },
    {
        &MEDIATYPE_Video,
        &MEDIASUBTYPE_NV24
    },
};
const AMOVIESETUP_PIN sudPins[] =
{
    {
        nullptr,
        FALSE,
        FALSE,
        FALSE,
        FALSE,
        &CLSID_NULL,
        nullptr,
        NUMELMS(sudPinTypes),
        sudPinTypes
    },
    {
        nullptr,
        FALSE,
        TRUE,
        FALSE,
        FALSE,
        &CLSID_NULL,
        nullptr,
        NUMELMS(sudPinTypes),
        sudPinTypes
    }
};
const AMOVIESETUP_FILTER sudFilter =
{
    &CLSID_AC_FILTER,
    L"Anime4KCPP for DirectShow",
    MERIT_DO_NOT_USE,
    2,
    sudPins
};
CFactoryTemplate g_Templates[] = {
    {
        L"Anime4KCPP for DirectShow",
        &CLSID_AC_FILTER,
        Filter::CreateInstance,
        nullptr,
        &sudFilter
    },
    {
        L"Anime4KCPP Settings",
        &CLSID_AC_PROPERTY_PAGE,
        PropertyPage::CreateInstance,
        nullptr,
        nullptr
    }
};
int g_cTemplates = NUMELMS(g_Templates);

STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2(TRUE);
}
STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2(FALSE);
}

extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);
BOOL APIENTRY DllMain(const HANDLE hModule, const DWORD dwReason, const LPVOID lpReserved)
{
    return DllEntryPoint((HINSTANCE)(hModule), dwReason, lpReserved);
}

CUnknown* Filter::CreateInstance(const LPUNKNOWN punk, HRESULT* const phr)
{
    auto object = new(std::nothrow) Filter{ NAME("Anime4KCPP for DirectShow"), punk, phr };
    if (!object && phr) *phr = E_OUTOFMEMORY;
    return object;
}
Filter::Filter(TCHAR* const name, const LPUNKNOWN punk, HRESULT* const phr) noexcept : CTransformFilter(name, punk, CLSID_AC_FILTER)
{
    limit.width = gRegArgument.getLimitWidth();
    limit.height = gRegArgument.getLimitHeight();
    factor = gRegArgument.getFactor();
    auto ProcessorType = gRegArgument.getProcessorType();
    auto device = gRegArgument.getDevice();
    auto modelName = gRegArgument.getModelName();

    processor = ac::core::Processor::create(T2A(ProcessorType), device, T2A(modelName));
    if (!processor->ok() && phr) *phr = E_UNEXPECTED;
}
STDMETHODIMP Filter::NonDelegatingQueryInterface(REFIID riid, void** ppv)
{
    CheckPointer(ppv, E_POINTER);

    if (riid == IID_ISpecifyPropertyPages)
        return GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv);
    else
        return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
}
CBasePin* Filter::GetPin(const int n)
{
    HRESULT hr = S_OK;

    if (!m_pInput && !m_pOutput)
    {
        auto input = std::unique_ptr<CSideDataInputPin>{ new(std::nothrow) CSideDataInputPin{ NAME("Filter input pin"), this, &hr, L"Input" } };
        if (!input || FAILED(hr)) return nullptr;
        auto output = std::unique_ptr<CTransformOutputPin>{ new(std::nothrow) CTransformOutputPin{ NAME("Filter output pin"), this, &hr, L"Output" } };
        if (!output || FAILED(hr)) return nullptr;

        m_pInput = input.release();
        m_pOutput = output.release();
    }

    if (n == 0) return m_pInput;
    if (n == 1) return m_pOutput;
    return nullptr;
}
HRESULT Filter::CheckInputType(const CMediaType* const mtIn)
{
    CheckPointer(mtIn, E_POINTER);

    if (*mtIn->FormatType() != FORMAT_VideoInfo2 && *mtIn->FormatType() != FORMAT_VideoInfo)
        return VFW_E_TYPE_NOT_ACCEPTED;

    format = [&]() -> Format {
        // planar: YYYYUUVV
        if (*mtIn->Subtype() == MEDIASUBTYPE_I420 ||
            *mtIn->Subtype() == MEDIASUBTYPE_IYUV ||
            *mtIn->Subtype() == MEDIASUBTYPE_YV12) return Format{ ac::core::Image::UInt8, {2, 2}, false };
        // planar: YUV422
        if (*mtIn->Subtype() == MEDIASUBTYPE_YV16) return Format{ ac::core::Image::UInt8, {2, 1}, false };
        // planar: YUV444
        if (*mtIn->Subtype() == MEDIASUBTYPE_YV24) return Format{ ac::core::Image::UInt8, {1, 1}, false };
        // packed: YYYYUVUV
        if (*mtIn->Subtype() == MEDIASUBTYPE_NV12) return Format{ ac::core::Image::UInt8, {2, 2}, true };
        if (*mtIn->Subtype() == MEDIASUBTYPE_P010 ||
            *mtIn->Subtype() == MEDIASUBTYPE_P016) return Format{ ac::core::Image::UInt16, {2, 2}, true };
        // packed: YUV422
        if (*mtIn->Subtype() == MEDIASUBTYPE_P210 ||
            *mtIn->Subtype() == MEDIASUBTYPE_P216) return Format{ ac::core::Image::UInt16, {2, 1}, true };
        // packed: YUV444
        if (*mtIn->Subtype() == MEDIASUBTYPE_NV24) return Format{ ac::core::Image::UInt8, {1, 1}, true };
        return {};
    }();

    if (!format) return VFW_E_TYPE_NOT_ACCEPTED;

    auto checkVideoInfo = [&](auto* vi) -> HRESULT {
        if (vi->bmiHeader.biWidth > limit.width || vi->bmiHeader.biHeight > limit.height)
            return VFW_E_TYPE_NOT_ACCEPTED;
        return S_OK;
    };
    if (*mtIn->FormatType() == FORMAT_VideoInfo2)
        return checkVideoInfo(reinterpret_cast<VIDEOINFOHEADER2*>(mtIn->Format()));
    else
        return checkVideoInfo(reinterpret_cast<VIDEOINFOHEADER*>(mtIn->Format()));
}
HRESULT Filter::CheckTransform(const CMediaType* const mtIn, const CMediaType* const mtOut)
{
    CheckPointer(mtIn, E_POINTER);
    CheckPointer(mtOut, E_POINTER);

    if (*mtOut->FormatType() != FORMAT_VideoInfo2 && *mtOut->FormatType() != FORMAT_VideoInfo)
        return VFW_E_TYPE_NOT_ACCEPTED;
    if (*mtIn->Subtype() != *mtOut->Subtype())
        return VFW_E_TYPE_NOT_ACCEPTED;
    return S_OK;
}
HRESULT Filter::GetMediaType(const int pos, CMediaType* const mt)
{
    if (m_pInput->IsConnected() == FALSE) return E_UNEXPECTED;
    if (pos < 0) return E_INVALIDARG;
    if (pos > 0) return VFW_S_NO_MORE_ITEMS;

    CheckPointer(mt, E_POINTER);
    auto hr = m_pInput->ConnectionMediaType(mt);
    if (FAILED(hr)) return hr;

    auto setVideoInfo = [&](auto* vi) {
        luma.src.width = vi->bmiHeader.biWidth;
        luma.src.height = vi->bmiHeader.biHeight;
        luma.dst.width = static_cast<decltype(luma.dst.width)>(luma.src.width * factor);
        luma.dst.height = static_cast<decltype(luma.dst.height)>(luma.src.height * factor);
        luma.channels = 1;
        luma.part = format.subsampling.w * format.subsampling.h;

        chroma.src.width = luma.src.width / format.subsampling.w;
        chroma.src.height = (luma.src.height / format.subsampling.h) * (format.packed ? 1 : 2);
        chroma.dst.width = luma.dst.width / format.subsampling.w;
        chroma.dst.height = (luma.dst.height / format.subsampling.h) * (format.packed ? 1 : 2);
        chroma.channels = format.packed ? 2 : 1;
        chroma.part = 2;

        totalParts = luma.part + chroma.part;

        vi->bmiHeader.biWidth = luma.dst.width;
        vi->bmiHeader.biHeight = luma.dst.height;
        vi->bmiHeader.biSizeImage = DIBSIZE(vi->bmiHeader);
        mt->SetSampleSize(vi->bmiHeader.biSizeImage);
        SetRect(&vi->rcSource, 0, 0, luma.dst.width, luma.dst.height);
        SetRect(&vi->rcTarget, 0, 0, luma.dst.width, luma.dst.height);
    };
    if (*mt->FormatType() == FORMAT_VideoInfo2)
        setVideoInfo(reinterpret_cast<VIDEOINFOHEADER2*>(mt->Format()));
    else
        setVideoInfo(reinterpret_cast<VIDEOINFOHEADER*>(mt->Format()));

    return S_OK;
}
HRESULT Filter::DecideBufferSize(IMemAllocator* const alloctor, ALLOCATOR_PROPERTIES* const request)
{
    if (!m_pInput->IsConnected()) return E_UNEXPECTED;
    CheckPointer(alloctor, E_POINTER);
    CheckPointer(request, E_POINTER);

    request->cbBuffer = static_cast<decltype(request->cbBuffer)>(m_pOutput->CurrentMediaType().GetSampleSize());

    if (request->cbAlign == 0) request->cbAlign = 32;
    if (request->cBuffers == 0) request->cBuffers = 1;

    ALLOCATOR_PROPERTIES actual{};
    auto hr = alloctor->SetProperties(request, &actual);
    if (FAILED(hr)) return hr;

    if (request->cBuffers > actual.cBuffers || request->cbBuffer > actual.cbBuffer)
        return E_FAIL;

    return S_OK;
}
HRESULT Filter::Transform(IMediaSample* const in, IMediaSample* const out)
{
    CheckPointer(in, E_POINTER);
    CheckPointer(out, E_POINTER);

    BYTE* src{};
    BYTE* dst{};
    in->GetPointer(&src);
    out->GetPointer(&dst);

    ac::core::Image srcy{ luma.src.width, luma.src.height, luma.channels, format.type, src, ((in->GetActualDataLength() * luma.part) / totalParts) / luma.src.height };
    ac::core::Image dsty{ luma.dst.width, luma.dst.height, luma.channels, format.type, dst, ((out->GetActualDataLength() * luma.part) / totalParts) / luma.dst.height };
    processor->process(srcy, dsty, factor);
    if (!processor->ok()) return E_FAIL;

    ac::core::Image srcuv{ chroma.src.width, chroma.src.height, chroma.channels, format.type, src + srcy.size(), ((in->GetActualDataLength() * chroma.part) / totalParts) / chroma.src.height };
    ac::core::Image dstuv{ chroma.dst.width, chroma.dst.height, chroma.channels, format.type, dst + dsty.size(), ((out->GetActualDataLength() * chroma.part) / totalParts) / chroma.dst.height };
    ac::core::resize(srcuv, dstuv, 0.0, 0.0);

    Microsoft::WRL::ComPtr<IMediaSideData> inputSideData{};
    Microsoft::WRL::ComPtr<IMediaSideData> outputSideData{};
    if (SUCCEEDED(in->QueryInterface(CLSID_IMediaSideData, &inputSideData)) && SUCCEEDED(out->QueryInterface(CLSID_IMediaSideData, &outputSideData)))
    {
        const BYTE* data{};
        std::size_t size{};

        if (SUCCEEDED(inputSideData->GetSideData(IID_MediaSideDataHDR, &data, &size))) outputSideData->SetSideData(IID_MediaSideDataHDR, data, size);
        if (SUCCEEDED(inputSideData->GetSideData(IID_MediaSideDataHDRContentLightLevel, &data, &size))) outputSideData->SetSideData(IID_MediaSideDataHDRContentLightLevel, data, size);
        if (SUCCEEDED(inputSideData->GetSideData(IID_MediaSideDataHDR10Plus, &data, &size))) outputSideData->SetSideData(IID_MediaSideDataHDR10Plus, data, size);
        if (SUCCEEDED(inputSideData->GetSideData(IID_MediaSideDataDOVIRPU, &data, &size))) outputSideData->SetSideData(IID_MediaSideDataDOVIRPU, data, size);
        if (SUCCEEDED(inputSideData->GetSideData(IID_MediaSideDataDOVIMetadata, &data, &size))) outputSideData->SetSideData(IID_MediaSideDataDOVIMetadata, data, size);
        if (SUCCEEDED(inputSideData->GetSideData(IID_MediaSideDataDOVIMetadataV2, &data, &size))) outputSideData->SetSideData(IID_MediaSideDataDOVIMetadataV2, data, size);
        if (SUCCEEDED(inputSideData->GetSideData(IID_MediaSideData3DOffset, &data, &size))) outputSideData->SetSideData(IID_MediaSideData3DOffset, data, size);
        if (SUCCEEDED(inputSideData->GetSideData(IID_MediaSideDataEIA608CC, &data, &size))) outputSideData->SetSideData(IID_MediaSideDataEIA608CC, data, size);
        if (SUCCEEDED(inputSideData->GetSideData(IID_MediaSideDataControlFlags, &data, &size))) outputSideData->SetSideData(IID_MediaSideDataControlFlags, data, size);
    }

    return S_OK;
}
STDMETHODIMP Filter::GetPages(CAUUID* const pages)
{
    CheckPointer(pages, E_POINTER);

    pages->cElems = 1;
    pages->pElems = static_cast<GUID*>(CoTaskMemAlloc(sizeof(GUID)));
    if (!pages->pElems) return E_OUTOFMEMORY;
    pages->pElems[0] = CLSID_AC_PROPERTY_PAGE;
    return S_OK;
}

CUnknown* PropertyPage::CreateInstance(const LPUNKNOWN punk, HRESULT* const phr)
{
    auto object = new(std::nothrow) PropertyPage{ NAME("Anime4KCPP for DirectShow Property Page"), punk, phr };
    if (!object && phr) *phr = E_OUTOFMEMORY;
    return object;
}
PropertyPage::PropertyPage(TCHAR* const name, const LPUNKNOWN punk, HRESULT* const /*phr*/) noexcept : CBasePropertyPage(name, punk, IDD_PROPPAGE, IDS_TITLE) {}
INT_PTR PropertyPage::OnReceiveMessage(const HWND hwnd, const UINT msg, const WPARAM wparam, const LPARAM lparam)
{
    switch (msg)
    {
    case WM_COMMAND:
    {
        if (isInitialized)
        {
            m_bDirty = TRUE;
            if (m_pPageSite) m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }
        return 1;
    }
    }
    return CBasePropertyPage::OnReceiveMessage(hwnd, msg, wparam, lparam);
}
HRESULT PropertyPage::OnActivate()
{
    TCHAR buffer[StringBufferSize]{};

    auto factor = gRegArgument.getFactor();
    _stprintf_s(buffer, NUMELMS(buffer), TEXT("%.2lf"), factor);
    Edit_SetText(GetDlgItem(m_Dlg, IDC_EDIT_FACTOR), buffer);

    for (auto item : ac::specs::ProcessorList) ComboBox_AddString(GetDlgItem(m_Dlg, IDC_COMBO_PROCESSOR), A2T(item));
    auto ProcessorType = gRegArgument.getProcessorType();
    ComboBox_SelectString(GetDlgItem(m_Dlg, IDC_COMBO_PROCESSOR), -1, ProcessorType);

    auto device = gRegArgument.getDevice();
    _stprintf_s(buffer, NUMELMS(buffer), TEXT("%d"), device);
    Edit_SetText(GetDlgItem(m_Dlg, IDC_EDIT_DEVICE), buffer);

    for (auto item : ac::specs::ModelList) ComboBox_AddString(GetDlgItem(m_Dlg, IDC_COMBO_MODEL), A2T(item));
    auto modelName = gRegArgument.getModelName();
    ComboBox_SelectString(GetDlgItem(m_Dlg, IDC_COMBO_MODEL), -1, modelName);

    auto limitWidth = gRegArgument.getLimitWidth();
    _stprintf_s(buffer, NUMELMS(buffer), TEXT("%d"), limitWidth);
    Edit_SetText(GetDlgItem(m_Dlg, IDC_EDIT_LIMIT_WIDTH), buffer);

    auto limitHeight = gRegArgument.getLimitHeight();
    _stprintf_s(buffer, NUMELMS(buffer), TEXT("%d"), limitHeight);
    Edit_SetText(GetDlgItem(m_Dlg, IDC_EDIT_LIMIT_HEIGHT), buffer);

    util::asciiToWindowsAscii(ac::core::Processor::listInfo(), buffer, NUMELMS(buffer));
    Edit_SetText(GetDlgItem(m_Dlg, IDC_EDIT_INFO), buffer);

    Static_SetText(GetDlgItem(m_Dlg, IDC_STATIC_VERSION), TEXT(AC_CORE_VERSION_STR));
    Static_SetText(GetDlgItem(m_Dlg, IDC_STATIC_COPYRIGHT), TEXT("Copyright (c) 2020-") TEXT(AC_BUILD_YEAR) TEXT(" the Anime4KCPP project"));

    isInitialized = true;
    return S_OK;
}
HRESULT PropertyPage::OnDeactivate()
{
    isInitialized = false;
    return S_OK;
}
HRESULT PropertyPage::OnApplyChanges()
{
    TCHAR buffer[StringBufferSize]{};
    TCHAR* endptr{};

    Edit_GetText(GetDlgItem(m_Dlg, IDC_EDIT_FACTOR), buffer, NUMELMS(buffer));
    auto factor = _tcstod(buffer, &endptr);
    if (endptr == buffer) factor = RegArgument::FactorDefault;
    gRegArgument.setFactor(factor);

    ComboBox_GetText(GetDlgItem(m_Dlg, IDC_COMBO_PROCESSOR), buffer, NUMELMS(buffer));
    gRegArgument.setProcessorType(buffer);

    Edit_GetText(GetDlgItem(m_Dlg, IDC_EDIT_DEVICE), buffer, NUMELMS(buffer));
    auto device = _tcstol(buffer, &endptr, 10);
    if (endptr == buffer) device = RegArgument::DeviceDefault;
    gRegArgument.setDevice(device);

    Edit_GetText(GetDlgItem(m_Dlg, IDC_EDIT_LIMIT_WIDTH), buffer, NUMELMS(buffer));
    auto limitWidth = _tcstol(buffer, &endptr, 10);
    if (endptr == buffer) limitWidth = RegArgument::LimitWidthDefault;
    gRegArgument.setLimitWidth(limitWidth);

    Edit_GetText(GetDlgItem(m_Dlg, IDC_EDIT_LIMIT_HEIGHT), buffer, NUMELMS(buffer));
    auto limitHeight = _tcstol(buffer, &endptr, 10);
    if (endptr == buffer) limitHeight = RegArgument::LimitHeightDefault;
    gRegArgument.setLimitHeight(limitHeight);

    ComboBox_GetText(GetDlgItem(m_Dlg, IDC_COMBO_MODEL), buffer, NUMELMS(buffer));
    gRegArgument.setModelName(buffer);

    return S_OK;
}
