#ifndef AC_CORE_IMAGE_HPP
#define AC_CORE_IMAGE_HPP

#include <cstdint>
#include <memory>

#include "ACExport.hpp" // Generated by CMake

namespace ac::core
{
    class Image;

    // convert RGB or RGBA to YUV.
    // if `yuv` is not an empty image, ensure its shape is correct, which won't be checked.
    // `rgb` and `yuv` can be the same image, which will be converted in place.
    AC_EXPORT void rgb2yuv(const Image& rgb, Image& yuv);
    // convert RGB or RGBA to Y and UV.
    // if `y` and `uv` are not empty images, ensure their shapes are correct, which won't be checked.
    // `rgb`, `y` and `uv` **cannot** be the same image.
    AC_EXPORT void rgb2yuv(const Image& rgb, Image& y, Image& uv);
    // convert RGB or RGBA to Y, U and V.
    // if `y`, `u` and `v` are not empty images, ensure their shapes are correct, which won't be checked.
    // `rgb`, `y`, `u` and `v` **cannot** be the same image.
    AC_EXPORT void rgb2yuv(const Image& rgb, Image& y, Image& u, Image& v);

    // convert RGBA to YUVA.
    // if `yuva` is not an empty image, ensure its shape is correct, which won't be checked.
    // `rgba` and `yuva` can be the same image, which will be converted in place.
    AC_EXPORT void rgba2yuva(const Image& rgba, Image& yuva);
    // convert RGBA to Y and UVA.
    // if `y` and `uva` are not empty images, ensure their shapes are correct, which won't be checked.
    // `rgba`, `y` and `uva` **cannot** be the same image.
    AC_EXPORT void rgba2yuva(const Image& rgba, Image& y, Image& uva);
    // convert RGBA to Y, U, V and A.
    // if `y`, `u`, `v` and `a` are not empty images, ensure their shapes are correct, which won't be checked.
    // `rgba`, `y`, `u`, `v` and `a` **cannot** be the same image.
    AC_EXPORT void rgba2yuva(const Image& rgba, Image& y, Image& u, Image& v, Image& a);

    // convert YUV to RGB.
    // if `rgb` is not an empty image, ensure its shape is correct, which won't be checked.
    // `yuv` and `rgb` can be the same image, which will be converted in place.
    AC_EXPORT void yuv2rgb(const Image& yuv, Image& rgb);
    // convert Y and UV to RGB.
    // if `rgb` is not an empty image, ensure its shape is correct, which won't be checked.
    // `y`, `uv` and `rgb` **cannot** be the same image.
    AC_EXPORT void yuv2rgb(const Image& y, const Image& uv, Image& rgb);
    // convert Y, U and V to RGB.
    // if `rgb` is not an empty image, ensure its shape is correct, which won't be checked.
    // `y`, `u`, `v` and `rgb` **cannot** be the same image.
    AC_EXPORT void yuv2rgb(const Image& y, const Image& u, const Image& v, Image& rgb);

    // convert YUVA to RGBA.
    // if `rgba` is not an empty image, ensure its shape is correct, which won't be checked.
    // `yuva` and `rgba` can be the same image, which will be converted in place.
    AC_EXPORT void yuva2rgba(const Image& yuva, Image& rgba);
    // convert Y and UVA to RGBA.
    // if `rgba` is not an empty image, ensure its shape is correct, which won't be checked.
    // `y`, `uva` and `rgba` **cannot** be the same image.
    AC_EXPORT void yuva2rgba(const Image& y, const Image& uva, Image& rgba);
    // convert Y, U and V to RGBA.
    // if `rgba` is not an empty image, ensure its shape is correct, which won't be checked.
    // `y`, `u`, `v`, `a` and `rgba` **cannot** be the same image.
    AC_EXPORT void yuva2rgba(const Image& y, const Image& u, const Image& v, const Image& a, Image& rgba);

    // remove padding in the stride of `src`, if necessary.
    // `src` and `dst` can be same.
    AC_EXPORT void unpadding(const Image& src, Image& dst) noexcept;

    // left shift pixel.
    // modify in place.
    AC_EXPORT void shl(Image& image, int n) noexcept;
    // left shift pixel.
    // `src` and `dst` can be same.
    AC_EXPORT void shl(const Image& src, Image& dst, int n) noexcept;
    // right shift pixel.
    // modify in place.
    AC_EXPORT void shr(Image& image, int n) noexcept;
    // right shift pixel.
    // `src` and `dst` can be same.
    AC_EXPORT void shr(const Image& src, Image& dst, int n) noexcept;

    // get an image from `src` with data type conversion.
    // if no need to convert, return `src` directly.
    AC_EXPORT Image astype(const Image& src, int type) noexcept;
    // copy src's pixels to dst with optional data type conversion.
    // if `src` is empty, dst will be empty too.
    // if `src` and `dst` is the same image, do nothing.
    AC_EXPORT void copy(const Image& src, Image& dst) noexcept;

    // crop the given area from `src`.
    AC_EXPORT Image crop(const Image& src, int x, int y, int w, int h) noexcept;

    enum ImresizeModes
    {
        IMRESIZE_POINT,
        IMRESIZE_CATMULL_ROM,        // b = 0, c = 0.5 or a = -0.5
        IMRESIZE_MITCHELL_NETRAVALI, // b = 1/3, c = 1/3
        IMRESIZE_BICUBIC_0_60,       // b = 0, c = 0.6 or a = -0.6
        IMRESIZE_BICUBIC_0_75,       // b = 0, c = 0.75 or a = -0.75
        IMRESIZE_BICUBIC_0_100,      // b = 0, c = 1 or a = -1
        IMRESIZE_BICUBIC_20_50,      // b = 0.2, c = 0.5
        IMRESIZE_SOFTCUBIC50,        // b = 0.5, c = 0.5
        IMRESIZE_SOFTCUBIC75,        // b = 0.75, c = 0.25
        IMRESIZE_SOFTCUBIC100,       // b = 1, c = 0
        IMRESIZE_LANCZOS2,
        IMRESIZE_LANCZOS3,
        IMRESIZE_LANCZOS4,
        IMRESIZE_SPLINE16,
        IMRESIZE_SPLINE36,
        IMRESIZE_SPLINE64,
        IMRESIZE_BILINEAR,
    };
    // Resize the `src` based on the size of the `dst` if `fx` or `fy` <= 0, otherwise, calculate the size using `fx` and `fy`.
    // if `dst` is empty and fx or fy <= 0, nothing will be done.
    // if target size is same as `src`(eg: `fx` and `fy` == 1), then just make `dst` = `src` and return, no data will be copied.
    // `src` and `dst` can be the same image.
    AC_EXPORT void resize(const Image& src, Image& dst, double fx, double fy, int mode = IMRESIZE_BILINEAR) noexcept;
    // if `fx` or `fy` <= 0, return `src`, otherwise, calculate the size using `fx` and `fy`.
    AC_EXPORT Image resize(const Image& src, double fx, double fy, int mode = IMRESIZE_BILINEAR) noexcept;

    enum ImreadModes
    {
        IMREAD_UNCHANGED = 0,
        IMREAD_GRAYSCALE = 1,
        IMREAD_COLOR     = 3,
        IMREAD_RGB       = 3,
        IMREAD_RGBA      = 4,
    };
    AC_EXPORT Image imdecode(const void* buffer, int size, int mode = IMREAD_UNCHANGED) noexcept;
#ifndef AC_CORE_DISABLE_IMAGE_IO
    AC_EXPORT Image imread(const char* filename, int mode = IMREAD_UNCHANGED) noexcept;
    AC_EXPORT bool imwrite(const char* filename, const Image& image) noexcept;
#endif
}

class ac::core::Image
{
private:
    struct ImageData;

public:
    // 2(float) or 1(int) or 0(uint) << 8 | sizeof (type)
    using ElementType = int;
    static constexpr ElementType UInt8   = 0 << 8 | 1;
    static constexpr ElementType UInt16  = 0 << 8 | 2;
    static constexpr ElementType Float32 = 2 << 8 | 4;

public:
    AC_EXPORT Image() noexcept;
    AC_EXPORT Image(int w, int h, int c, ElementType elementType, int stride = 0);
    AC_EXPORT Image(int w, int h, int c, ElementType elementType, void* data, int stride = 0);
    AC_EXPORT Image(const Image&) noexcept;
    AC_EXPORT Image(Image&&) noexcept;
    AC_EXPORT ~Image() noexcept;
    AC_EXPORT Image& operator=(const Image&) noexcept;
    AC_EXPORT Image& operator=(Image&&) noexcept;

    AC_EXPORT void create(int w, int h, int c, ElementType elementType, int stride = 0);
    AC_EXPORT void map(int w, int h, int c, ElementType elementType, void* data, int stride = 0) noexcept;
    AC_EXPORT void from(int w, int h, int c, ElementType elementType, const void* data, int stride = 0);
    AC_EXPORT void to(void* data, int stride = 0) const noexcept;
    AC_EXPORT Image clone() const;

public:
    int width() const noexcept { return w; }
    int height() const noexcept { return h; }
    int channels() const noexcept { return c; }
    int stride() const noexcept { return pitch; }
    int size() const noexcept { return h * pitch; }
    int elementSize() const noexcept { return elementType & 0xff; }
    int pixelSize() const noexcept { return c * elementSize(); }
    ElementType type() const noexcept { return elementType; }
    std::uint8_t* data() const noexcept { return static_cast<std::uint8_t*>(pixels); }
    std::uint8_t* line(const int y) const noexcept { return data() + y * pitch; }
    std::uint8_t* pixel(const int x, const int y) const noexcept { return line(y) + x * pixelSize(); }
    void* ptr() const noexcept { return pixels; }
    void* ptr(const int y) const noexcept { return line(y); }
    void* ptr(const int x, const int y) const noexcept { return pixel(x, y); }
    bool empty() const noexcept { return pixels == nullptr; }
    bool isUint() const noexcept { return (elementType >> 8) == 0; }
    bool isInt() const noexcept { return (elementType >> 8) == 1; }
    bool isFloat() const noexcept { return (elementType >> 8) == 2; }

    bool operator==(const Image& other) const noexcept { return this->pixels == other.pixels; }
    bool operator!=(const Image& other) const noexcept { return !operator==(other); }

private:
    int w, h, c;
    ElementType elementType;
    int pitch;
    void* pixels;
    std::shared_ptr<ImageData> dptr;
};

#endif
