#ifndef AC_CORE_MODEL_ARNET_HPP
#define AC_CORE_MODEL_ARNET_HPP

#include <cstddef>

#include "AC/Core/Model/Base.hpp"

#include "ACCoreExport.hpp" // Generated by CMake

namespace ac::core::model
{
    class ARNet;
}

class ac::core::model::ARNet
{
public:
    enum class Variant
    {
        B4_HDN, B4_HDNS, B4_LE, B4_LS,
        B8_HDN, B8_HDNS, B8_LE, B8_LS,
        B16_HDN, B16_HDNS, B16_LE, B16_LS,
        B24_HDN, B24_HDNS, B24_LE, B24_LS,
        B32_HDN, B32_HDNS, B32_LE, B32_LS,
        B48_HDN, B48_HDNS, B48_LE, B48_LS,
        B64_HDN, B64_HDNS, B64_LE, B64_LS
    };

public:
    AC_CORE_EXPORT ARNet(Variant v) noexcept;

public:
    // length in numbers
    int kernelLength() const noexcept { return 8 * 9 + 8 * 8 * 9 * blockNum * 2 + 8 * 4 * 9; }
    int biasLength() const noexcept { return 8 + 8 * blockNum * 2 + 4; }
    int kernelLength(const int idx) const noexcept { return (idx == 0) ? 8 * 9 : ((idx > 0 && idx < (blockNum * 2 + 1)) ? 8 * 8 * 9 : ((idx == (blockNum * 2 + 1)) ? 8 * 4 * 9 : 0)); }
    int biasLength(const int idx) const noexcept { return (idx >= 0 && idx < (blockNum * 2 + 1)) ? 8 : (idx == (blockNum * 2 + 1) ? 4 : 0); }

    // size in bytes
    std::size_t kernelSize() const noexcept { return kernelLength() * sizeof(float); }
    std::size_t biasSize() const noexcept { return biasLength() * sizeof(float); }
    std::size_t kernelSize(const int idx) const noexcept { return kernelLength(idx) * sizeof(float); }
    std::size_t biasSize(const int idx) const noexcept { return biasLength(idx) * sizeof(float); }

    int blocks() const noexcept { return blockNum; }
    int kernels() const noexcept { return blockNum * 2 + 2; }
    int biases() const noexcept { return blockNum * 2 + 2; }

    int kernelOffset(const int idx) const noexcept
    {
        if (idx <= 0) return 0;
        if (idx == 1) return 8 * 9;
        if (idx < kernels()) return 8 * 9 + (8 * 8 * 9) * (idx - 1);
        return kernelLength();
    }
    int biasOffset(const int idx) const noexcept
    {
        if (idx <= 0) return 0;
        if (idx == 1) return 8;
        if (idx < biases()) return 8 + 8 * (idx - 1);
        return biasLength();
    }

    const float* kernel(const int idx = 0) const noexcept { return kptr + kernelOffset(idx); }
    const float* bias(const int idx = 0) const noexcept { return bptr + biasOffset(idx); }

private:
    int blockNum;

    const float* kptr;
    const float* bptr;
};

#endif
