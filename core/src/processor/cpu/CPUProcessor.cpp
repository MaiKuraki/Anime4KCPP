#include <memory>
#include <sstream>
#include <string>

#include "AC/Core/SIMD.hpp"
#include "AC/Core/Model.hpp"
#include "AC/Core/Processor.hpp"
#include "AC/Util/ThreadLocal.hpp"

#include "ACCoreExport.hpp" // Generated by CMake

namespace ac::core::cpu
{
    namespace arch
    {
        enum
        {
            Begin,
#       ifdef AC_CORE_WITH_EIGEN3
            Eigen3,
#       endif
#       ifdef AC_CORE_WITH_SSE
            SSE,
#       endif
#       ifdef AC_CORE_WITH_AVX
            AVX,
#       endif
#       ifdef AC_CORE_WITH_NEON
            NEON,
#       endif
#       ifdef AC_CORE_WITH_WASM_SIMD128
            WASM_SIMD128,
#       endif
            Generic,
            End
        };
        constexpr const char* NameList[] =
        {
            "Auto",
#       ifdef AC_CORE_WITH_EIGEN3
            "Eigen3",
#       endif
#       ifdef AC_CORE_WITH_SSE
            "SSE",
#       endif
#       ifdef AC_CORE_WITH_AVX
            "AVX",
#       endif
#       ifdef AC_CORE_WITH_NEON
            "NEON",
#       endif
#       ifdef AC_CORE_WITH_WASM_SIMD128
            "WASM_SIMD128",
#       endif
            "Generic"
        };
    }
    void conv3x3_1to8_relu_generic(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_relu_generic(const Image& src, Image& dst, const float* kernels, const float* biases);
    void deconv2x2_8to1_generic(const Image& src, Image& dst, const float* kernels);

    void conv3x3_1to8_identity_generic(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_lrelu_generic(const Image& src, Image& dst, const float* kernels, const float* biases, float negativeSlope);
    void conv3x3_8to8_residual_identity_generic(const Image& src, Image& dst, const float* kernels, const float* biases, const Image& id, float scale);
    void conv3x3_8to8_residual_add_identity_generic(const Image& src, Image& dst, const float* kernels, const float* biases, const Image& id, float scale, const Image& feat);
    void conv3x3_8to4_identity_generic(const Image& src, Image& dst, const float* kernels, const float* biases);
    void pixelshuffle_4to1_generic(const Image& src, Image& dst);
    void conv3x3_8to4_identity_pixelshuffle_4to1_generic(const Image& src, Image& dst, const float* kernels, const float* biases);
#ifdef AC_CORE_WITH_EIGEN3
    void conv3x3_1to8_relu_eigen3(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_relu_eigen3(const Image& src, Image& dst, const float* kernels, const float* biases);
    void deconv2x2_8to1_eigen3(const Image& src, Image& dst, const float* kernels);

    void conv3x3_1to8_identity_eigen3(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_lrelu_eigen3(const Image& src, Image& dst, const float* kernels, const float* biases, float negativeSlope);
    void conv3x3_8to8_residual_identity_eigen3(const Image& src, Image& dst, const float* kernels, const float* biases, const Image& id, float scale);
    void conv3x3_8to8_residual_add_identity_eigen3(const Image& src, Image& dst, const float* kernels, const float* biases, const Image& id, float scale, const Image& feat);
    void conv3x3_8to4_identity_eigen3(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to4_identity_pixelshuffle_4to1_eigen3(const Image& src, Image& dst, const float* kernels, const float* biases);
#endif
#ifdef AC_CORE_WITH_SSE
    void conv3x3_1to8_relu_sse(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_relu_sse(const Image& src, Image& dst, const float* kernels, const float* biases);
    void deconv2x2_8to1_sse(const Image& src, Image& dst, const float* kernels);

    void conv3x3_1to8_identity_sse(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_lrelu_sse(const Image& src, Image& dst, const float* kernels, const float* biases, float negativeSlope);
    void conv3x3_8to8_residual_identity_sse(const Image& src, Image& dst, const float* kernels, const float* biases, const Image& id, float scale);
    void conv3x3_8to8_residual_add_identity_sse(const Image& src, Image& dst, const float* kernels, const float* biases, const Image& id, float scale, const Image& feat);
    void conv3x3_8to4_identity_sse(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to4_identity_pixelshuffle_4to1_sse(const Image& src, Image& dst, const float* kernels, const float* biases);

#endif
#ifdef AC_CORE_WITH_AVX
    void conv3x3_1to8_relu_avx(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_relu_avx(const Image& src, Image& dst, const float* kernels, const float* biases);
    void deconv2x2_8to1_avx(const Image& src, Image& dst, const float* kernels);

    void conv3x3_1to8_identity_avx(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_lrelu_avx(const Image& src, Image& dst, const float* kernels, const float* biases, float negativeSlope);
    void conv3x3_8to8_residual_identity_avx(const Image& src, Image& dst, const float* kernels, const float* biases, const Image& id, float scale);
    void conv3x3_8to8_residual_add_identity_avx(const Image& src, Image& dst, const float* kernels, const float* biases, const Image& id, float scale, const Image& feat);
    void conv3x3_8to4_identity_avx(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to4_identity_pixelshuffle_4to1_avx(const Image& src, Image& dst, const float* kernels, const float* biases);
#endif
#ifdef AC_CORE_WITH_NEON
    void conv3x3_1to8_relu_neon(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_relu_neon(const Image& src, Image& dst, const float* kernels, const float* biases);
    void deconv2x2_8to1_neon(const Image& src, Image& dst, const float* kernels);

    void conv3x3_1to8_identity_neon(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_lrelu_neon(const Image& src, Image& dst, const float* kernels, const float* biases, float negativeSlope);
    void conv3x3_8to8_residual_identity_neon(const Image& src, Image& dst, const float* kernels, const float* biases, const Image& id, float scale);
    void conv3x3_8to8_residual_add_identity_neon(const Image& src, Image& dst, const float* kernels, const float* biases, const Image& id, float scale, const Image& feat);
    void conv3x3_8to4_identity_neon(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to4_identity_pixelshuffle_4to1_neon(const Image& src, Image& dst, const float* kernels, const float* biases);
#endif
#ifdef AC_CORE_WITH_WASM_SIMD128
    void conv3x3_1to8_relu_wasm_simd128(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_relu_wasm_simd128(const Image& src, Image& dst, const float* kernels, const float* biases);
    void deconv2x2_8to1_wasm_simd128(const Image& src, Image& dst, const float* kernels);

    void conv3x3_1to8_identity_wasm_simd128(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_lrelu_wasm_simd128(const Image& src, Image& dst, const float* kernels, const float* biases, float negativeSlope);
    void conv3x3_8to8_residual_identity_wasm_simd128(const Image& src, Image& dst, const float* kernels, const float* biases, const Image& id, float scale);
    void conv3x3_8to8_residual_add_identity_wasm_simd128(const Image& src, Image& dst, const float* kernels, const float* biases, const Image& id, float scale, const Image& feat);
    void conv3x3_8to4_identity_wasm_simd128(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to4_identity_pixelshuffle_4to1_wasm_simd128(const Image& src, Image& dst, const float* kernels, const float* biases);
#endif

    class ImageBuffer
    {
    public:
        ImageBuffer() noexcept = default;
        ImageBuffer(const ImageBuffer&) = delete;
        ImageBuffer(ImageBuffer&&) noexcept = delete;
        ImageBuffer& operator=(const ImageBuffer&) = delete;
        ImageBuffer& operator=(ImageBuffer&&) noexcept = delete;

        Image& get(const int width, const int height, const int channels, const Image::ElementType type)
        {
            if (buffer.empty() || buffer.width() != width || buffer.height() != height || buffer.type() != type)
                buffer.create(width, height, channels, type);

            return buffer;
        }

    private:
        Image buffer{};
    };

    class CPUProcessorBase : public Processor
    {
    public:
        CPUProcessorBase(const int arch) noexcept
        {
            idx = (arch > arch::Begin && arch < arch::End) ? arch : []() -> int {
                // x86
#           ifdef AC_CORE_WITH_AVX
                if (simd::supportAVX()) return arch::AVX;
#           endif
#           ifdef AC_CORE_WITH_SSE
                if (simd::supportSSE()) return arch::SSE;
#           endif
                // arm
#           ifdef AC_CORE_WITH_NEON
                if (simd::supportNEON()) return arch::NEON;
#           endif
                // wasm
#           ifdef AC_CORE_WITH_WASM_SIMD128
                return arch::WASM_SIMD128;
#           endif
                // generic
#           ifdef AC_CORE_WITH_EIGEN3
                return arch::Eigen3;
#           else
                return arch::Generic;
#           endif
            }();

            switch (idx)
            {
#       ifdef AC_CORE_WITH_EIGEN3
            case arch::Eigen3:
                conv3x3_1to8_relu = conv3x3_1to8_relu_eigen3;
                conv3x3_8to8_relu = conv3x3_8to8_relu_eigen3;
                deconv2x2_8to1 = deconv2x2_8to1_eigen3;

                conv3x3_1to8_identity = conv3x3_1to8_identity_eigen3;
                conv3x3_8to8_lrelu = conv3x3_8to8_lrelu_eigen3;
                conv3x3_8to8_residual_identity = conv3x3_8to8_residual_identity_eigen3;
                conv3x3_8to8_residual_add_identity = conv3x3_8to8_residual_add_identity_eigen3;
                conv3x3_8to4_identity = conv3x3_8to4_identity_eigen3;
                pixelshuffle_4to1 = pixelshuffle_4to1_generic;
                conv3x3_8to4_identity_pixelshuffle_4to1 = conv3x3_8to4_identity_pixelshuffle_4to1_eigen3;
                break;
#       endif
#       ifdef AC_CORE_WITH_SSE
            case arch::SSE:
                conv3x3_1to8_relu = conv3x3_1to8_relu_sse;
                conv3x3_8to8_relu = conv3x3_8to8_relu_sse;
                deconv2x2_8to1 = deconv2x2_8to1_sse;

                conv3x3_1to8_identity = conv3x3_1to8_identity_sse;
                conv3x3_8to8_lrelu = conv3x3_8to8_lrelu_sse;
                conv3x3_8to8_residual_identity = conv3x3_8to8_residual_identity_sse;
                conv3x3_8to8_residual_add_identity = conv3x3_8to8_residual_add_identity_sse;
                conv3x3_8to4_identity = conv3x3_8to4_identity_sse;
                pixelshuffle_4to1 = pixelshuffle_4to1_generic;
                conv3x3_8to4_identity_pixelshuffle_4to1 = conv3x3_8to4_identity_pixelshuffle_4to1_sse;
                break;
#       endif
#       ifdef AC_CORE_WITH_AVX
            case arch::AVX:
                conv3x3_1to8_relu = conv3x3_1to8_relu_avx;
                conv3x3_8to8_relu = conv3x3_8to8_relu_avx;
                deconv2x2_8to1 = deconv2x2_8to1_avx;

                conv3x3_1to8_identity = conv3x3_1to8_identity_avx;
                conv3x3_8to8_lrelu = conv3x3_8to8_lrelu_avx;
                conv3x3_8to8_residual_identity = conv3x3_8to8_residual_identity_avx;
                conv3x3_8to8_residual_add_identity = conv3x3_8to8_residual_add_identity_avx;
                conv3x3_8to4_identity = conv3x3_8to4_identity_avx;
                pixelshuffle_4to1 = pixelshuffle_4to1_generic;
                conv3x3_8to4_identity_pixelshuffle_4to1 = conv3x3_8to4_identity_pixelshuffle_4to1_avx;
                break;
#       endif
#       ifdef AC_CORE_WITH_NEON
            case arch::NEON:
                conv3x3_1to8_relu = conv3x3_1to8_relu_neon;
                conv3x3_8to8_relu = conv3x3_8to8_relu_neon;
                deconv2x2_8to1 = deconv2x2_8to1_neon;

                conv3x3_1to8_identity = conv3x3_1to8_identity_neon;
                conv3x3_8to8_lrelu = conv3x3_8to8_lrelu_neon;
                conv3x3_8to8_residual_identity = conv3x3_8to8_residual_identity_neon;
                conv3x3_8to8_residual_add_identity = conv3x3_8to8_residual_add_identity_neon;
                conv3x3_8to4_identity = conv3x3_8to4_identity_neon;
                pixelshuffle_4to1 = pixelshuffle_4to1_generic;
                conv3x3_8to4_identity_pixelshuffle_4to1 = conv3x3_8to4_identity_pixelshuffle_4to1_neon;
                break;
#       endif
#       ifdef AC_CORE_WITH_WASM_SIMD128
            case arch::WASM_SIMD128:
                conv3x3_1to8_relu = conv3x3_1to8_relu_wasm_simd128;
                conv3x3_8to8_relu = conv3x3_8to8_relu_wasm_simd128;
                deconv2x2_8to1 = deconv2x2_8to1_wasm_simd128;

                conv3x3_1to8_identity = conv3x3_1to8_identity_wasm_simd128;
                conv3x3_8to8_lrelu = conv3x3_8to8_lrelu_wasm_simd128;
                conv3x3_8to8_residual_identity = conv3x3_8to8_residual_identity_wasm_simd128;
                conv3x3_8to8_residual_add_identity = conv3x3_8to8_residual_add_identity_wasm_simd128;
                conv3x3_8to4_identity = conv3x3_8to4_identity_wasm_simd128;
                pixelshuffle_4to1 = pixelshuffle_4to1_generic;
                conv3x3_8to4_identity_pixelshuffle_4to1 = conv3x3_8to4_identity_pixelshuffle_4to1_wasm_simd128;
                break;
#       endif
            default:
                conv3x3_1to8_relu = conv3x3_1to8_relu_generic;
                conv3x3_8to8_relu = conv3x3_8to8_relu_generic;
                deconv2x2_8to1 = deconv2x2_8to1_generic;

                conv3x3_1to8_identity = conv3x3_1to8_identity_generic;
                conv3x3_8to8_lrelu = conv3x3_8to8_lrelu_generic;
                conv3x3_8to8_residual_identity = conv3x3_8to8_residual_identity_generic;
                conv3x3_8to8_residual_add_identity = conv3x3_8to8_residual_add_identity_generic;
                conv3x3_8to4_identity = conv3x3_8to4_identity_generic;
                pixelshuffle_4to1 = pixelshuffle_4to1_generic;
                conv3x3_8to4_identity_pixelshuffle_4to1 = conv3x3_8to4_identity_pixelshuffle_4to1_generic;
                break;
            }
        }
        ~CPUProcessorBase() noexcept override = default;

        const char* name() const noexcept override
        {
            return arch::NameList[idx];
        }
        int type() const noexcept override
        {
            return Processor::CPU;
        }
        const char* typeName() const noexcept override
        {
            return "CPU";
        }
    protected:
        void (*conv3x3_1to8_relu)(const Image& src, Image& dst, const float* kernels, const float* biases);
        void (*conv3x3_8to8_relu)(const Image& src, Image& dst, const float* kernels, const float* biases);
        void (*deconv2x2_8to1)(const Image& src, Image& dst, const float* kernels);

        void (*conv3x3_1to8_identity)(const Image& src, Image& dst, const float* kernels, const float* biases);
        void (*conv3x3_8to8_lrelu)(const Image& src, Image& dst, const float* kernels, const float* biases, float negativeSlope);
        void (*conv3x3_8to8_residual_identity)(const Image& src, Image& dst, const float* kernels, const float* biases, const Image& id, float scale);
        void (*conv3x3_8to8_residual_add_identity)(const Image& src, Image& dst, const float* kernels, const float* biases, const Image& id, float scale, const Image& feat);
        void (*conv3x3_8to4_identity)(const Image& src, Image& dst, const float* kernels, const float* biases);
        void (*pixelshuffle_4to1)(const Image& src, Image& dst);
        void (*conv3x3_8to4_identity_pixelshuffle_4to1)(const Image& src, Image& dst, const float* kernels, const float* biases);
    };

    template<typename Model>
    class CPUProcessorSeqCNN : public CPUProcessorBase
    {
    public:
        CPUProcessorSeqCNN(const int arch, const Model& model) noexcept : CPUProcessorBase(arch), model(model) {}
        ~CPUProcessorSeqCNN() noexcept override = default;

    protected:
        Model model;
    };

    template<typename Model>
    class CPUProcessor;
}

template<>
class ac::core::cpu::CPUProcessor<ac::core::model::ACNet> : public ac::core::cpu::CPUProcessorSeqCNN<ac::core::model::ACNet>
{
public:
    CPUProcessor(int arch, const model::ACNet& model) noexcept;
    ~CPUProcessor() noexcept override;

private:
    void process(const Image& src, Image& dst) override;

private:
    util::ThreadLocal<ImageBuffer> tmp1ImageBuffers{};
    util::ThreadLocal<ImageBuffer> tmp2ImageBuffers{};
};

ac::core::cpu::CPUProcessor<ac::core::model::ACNet>::CPUProcessor(const int arch, const model::ACNet& model) noexcept : CPUProcessorSeqCNN(arch, model) {}
ac::core::cpu::CPUProcessor<ac::core::model::ACNet>::~CPUProcessor() noexcept = default;

void ac::core::cpu::CPUProcessor<ac::core::model::ACNet>::process(const Image& src, Image& dst)
{
    auto& tmp1ImageBuffer = tmp1ImageBuffers.local();
    auto& tmp2ImageBuffer = tmp2ImageBuffers.local();

    auto& tmp1 = tmp1ImageBuffer.get(src.width(), src.height(), 8, ac::core::Image::Float32);
    auto& tmp2 = tmp2ImageBuffer.get(src.width(), src.height(), 8, ac::core::Image::Float32);

    conv3x3_1to8_relu(src, tmp1, model.kernel(0), model.bias(0));
    conv3x3_8to8_relu(tmp1, tmp2, model.kernel(1), model.bias(1));
    conv3x3_8to8_relu(tmp2, tmp1, model.kernel(2), model.bias(2));
    conv3x3_8to8_relu(tmp1, tmp2, model.kernel(3), model.bias(3));
    conv3x3_8to8_relu(tmp2, tmp1, model.kernel(4), model.bias(4));
    conv3x3_8to8_relu(tmp1, tmp2, model.kernel(5), model.bias(5));
    conv3x3_8to8_relu(tmp2, tmp1, model.kernel(6), model.bias(6));
    conv3x3_8to8_relu(tmp1, tmp2, model.kernel(7), model.bias(7));
    conv3x3_8to8_relu(tmp2, tmp1, model.kernel(8), model.bias(8));
    deconv2x2_8to1(tmp1, dst, model.kernel(9));
}

template<>
AC_CORE_EXPORT std::shared_ptr<ac::core::Processor> ac::core::Processor::create<ac::core::Processor::CPU ,ac::core::model::ACNet>(const int idx, const model::ACNet& model)
{
    return std::make_shared<cpu::CPUProcessor<model::ACNet>>(idx, model);
}


template<>
class ac::core::cpu::CPUProcessor<ac::core::model::ARNet> : public ac::core::cpu::CPUProcessorSeqCNN<ac::core::model::ARNet>
{
public:
    CPUProcessor(int arch, const model::ARNet& model) noexcept;
    ~CPUProcessor() noexcept override;

private:
    void process(const Image& src, Image& dst) override;

private:
    util::ThreadLocal<ImageBuffer> tmp1ImageBuffers{};
    util::ThreadLocal<ImageBuffer> tmp2ImageBuffers{};
    util::ThreadLocal<ImageBuffer> featImageBuffers{};
};

ac::core::cpu::CPUProcessor<ac::core::model::ARNet>::CPUProcessor(const int arch, const model::ARNet& model) noexcept : CPUProcessorSeqCNN(arch, model) {}
ac::core::cpu::CPUProcessor<ac::core::model::ARNet>::~CPUProcessor() noexcept = default;

void ac::core::cpu::CPUProcessor<ac::core::model::ARNet>::process(const Image& src, Image& dst)
{
    auto& tmp1ImageBuffer = tmp1ImageBuffers.local();
    auto& tmp2ImageBuffer = tmp2ImageBuffers.local();
    auto& featImageBuffer = featImageBuffers.local();

    auto& tmp1 = tmp1ImageBuffer.get(src.width(), src.height(), 8, ac::core::Image::Float32);
    auto& tmp2 = tmp2ImageBuffer.get(src.width(), src.height(), 8, ac::core::Image::Float32);
    auto& feat = featImageBuffer.get(src.width(), src.height(), 8, ac::core::Image::Float32);

    int l = 0;
    //head
    conv3x3_1to8_identity(src, feat, model.kernel(l), model.bias(l)); l++;
    //body
    conv3x3_8to8_lrelu(feat, tmp1, model.kernel(l), model.bias(l), 0.2f); l++;
    conv3x3_8to8_residual_identity(tmp1, tmp2, model.kernel(l), model.bias(l), feat, 0.2f); l++;
    for (int i = 0; i < model.blocks() - 2; i++)
    {
        conv3x3_8to8_lrelu(tmp2, tmp1, model.kernel(l), model.bias(l), 0.2f); l++;
        conv3x3_8to8_residual_identity(tmp1, tmp2, model.kernel(l), model.bias(l), tmp2, 0.2f); l++;
    }
    conv3x3_8to8_lrelu(tmp2, tmp1, model.kernel(l), model.bias(l), 0.2f); l++;
    conv3x3_8to8_residual_add_identity(tmp1, tmp2, model.kernel(l), model.bias(l), tmp2, 0.2f, feat); l++;
    // upscale
    conv3x3_8to4_identity_pixelshuffle_4to1(tmp2, dst, model.kernel(l), model.bias(l));
}

template<>
AC_CORE_EXPORT std::shared_ptr<ac::core::Processor> ac::core::Processor::create<ac::core::Processor::CPU, ac::core::model::ARNet>(const int idx, const model::ARNet& model)
{
    return std::make_shared<cpu::CPUProcessor<model::ARNet>>(idx, model);
}


template<>
AC_CORE_EXPORT const char* ac::core::Processor::info<ac::core::Processor::CPU>()
{
    static auto infoBuffer = []() -> std::string {
        std::ostringstream buffer{ "CPU:\n", std::ios_base::ate };
        for (int i = cpu::arch::Begin; i < cpu::arch::End; i++)
        {
            buffer << "  [" << i << "] " << cpu::arch::NameList[i] << '\n';
        }
        return buffer.str();
    }();
    return infoBuffer.c_str();
}
